---
title: "P24-203"
subtitle: "Code"
output: html_notebook
---

# SETUP
```{r warning=FALSE, message=FALSE}
library(harmony)
library(Seurat)
library(SoupX)
library(patchwork)
library(scran)
library(cowplot)
library(patchwork)
library(ggplot2)
library(reshape2)
library(Polychrome)
library(foreach)
library(doParallel)
library(GSEABase)
library(AUCell)
library(scran)
library(scuttle)
library(here)
library(readr)
library(scLink)
```

# Functions
```{r}
plot_integrated_clusters = function (srat) { 
  ## take an integrated Seurat object, plot distributions over orig.ident

  count_table <- table(srat@meta.data$seurat_clusters, srat@meta.data$orig.ident)
  count_mtx   <- as.data.frame.matrix(count_table)
  count_mtx$cluster <- rownames(count_mtx)
  melt_mtx    <- melt(count_mtx)
  melt_mtx$cluster <- as.factor(melt_mtx$cluster)
  
  cluster_size   <- aggregate(value ~ cluster, data = melt_mtx, FUN = sum)
  
  sorted_labels <- paste(sort(as.integer(levels(cluster_size$cluster)),decreasing = T))
  cluster_size$cluster <- factor(cluster_size$cluster,levels = sorted_labels)
  melt_mtx$cluster <- factor(melt_mtx$cluster,levels = sorted_labels)
  
  colnames(melt_mtx)[2] <- "dataset"
  
  melt_mtx$dataset <- factor(melt_mtx$dataset, levels = unique(melt_mtx$dataset))

  my_colors <- createPalette(length(unique(melt_mtx$dataset)),  c("#ff0000", "#00ff00", "#0000ff"))
# Assign names to my_colors that match the levels of melt_mtx$dataset
  names(my_colors) <- levels(melt_mtx$dataset)
  
  p1 <- ggplot(cluster_size, aes(y= cluster,x = value)) + geom_bar(position="dodge", stat="identity",fill = "grey60") + 
    theme_bw() + scale_x_log10() + xlab("Cells per cluster, log10 scale") + ylab("")
  p2 <- ggplot(melt_mtx,aes(x=cluster,y=value,fill=dataset)) + 
    geom_bar(position="fill", stat="identity") + theme_bw() + coord_flip() + 
    scale_fill_manual(values = my_colors) +
    ylab("Fraction of cells in each dataset") + xlab("Cluster number") + theme(legend.position="top")
  
  p2 + p1 + plot_layout(widths = c(3,1))
}
```

# Load data
```{r}
data_directory <- "~/Git/P24-203/data/count/"
sample_names <- list.files(data_directory)
```

# Create Seurat object
```{r warning=FALSE}

names = c("181015_21V", "181015_22S", "181217_APn1_6V", "181217_APn1_12W",
          "181217_APn1_19S","181228_AP-rna-gradient_14V", 
          "181228_AP-rna-gradient_20W", "181228_AP-rna-gradient_27W",
          "181228_AP-rna-gradient_31S", "181228_AP-rna-gradient_36S",
          "181228_AP-rna-wash_9V", "181228_AP-rna-wash_16W", "181228_AP-rna-wash_26S",
          "190222_7W", "190222_37W", "190222_34W", "190222_39S", 
          "190222_40S", "190222_23V", "190222_25V", "SRR19661760", "SRR19661761") 

suffix = c("/outs/filtered_feature_bc_matrix")

sample <- gsub(".*_", "", names)
sample <- sort(sample)
metadata = c() 

for (i in 1:length(names)){

  data_path <- paste(paste(data_directory, sample[i], sep = ""), suffix, sep = "") 
  data_path <- normalizePath(data_path)
  data <- Read10X(data_path)
  colnames(data) <- paste(sample[i], colnames(data), sep = "_")

  metadata = c(metadata, rep(sample[i], ncol(data)))
  
  if (i == 1) {
    dvc.data = data
  } 
  else {
    dvc.data = cbind(dvc.data, data)
  }
}

metadata = data.frame(metadata)
colnames(metadata) = "sample"
rownames(metadata) = colnames(dvc.data)

dvc <- CreateSeuratObject(counts = dvc.data, meta.data = metadata)
rownames(dvc@assays$RNA@layers$counts) <- rownames(dvc@assays$RNA)

```

# QC
```{r warning=FALSE, message=FALSE}

mito.genes <- grep(pattern = "^mt-", x = rownames(dvc@assays$RNA), value = TRUE)
percent.mito <- Matrix::colSums(dvc@assays$RNA@layers$counts[mito.genes,])/Matrix::colSums(dvc@assays$RNA@layers$counts)

ribo.genes <- grep(pattern = "^Rp", x = rownames(dvc@assays$RNA), value = TRUE)
percent.ribo <- Matrix::colSums(dvc@assays$RNA@layers$counts[ribo.genes,])/Matrix::colSums(dvc@assays$RNA@layers$counts)

# Save data to the Seurat object
mito.ribo = as.data.frame(cbind(percent.mito, percent.ribo))
colnames(mito.ribo) = c("percent.mito", "percent.ribo")

dvc <- AddMetaData(object = dvc, metadata = mito.ribo)

# Create the violin plot and adjust margins
vln <- VlnPlot(dvc, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2) 

print(vln)

vln2 <- VlnPlot(dvc, features = c("percent.mito", "percent.ribo"), ncol = 2)
print(vln2)

dvc <- subset(dvc, subset = percent.mito < .05)

dvc.list <- SplitObject(object = dvc, split.by = "sample")
```

# Data normalization per sample
```{r warning=FALSE}
cluster_assignments_list <- list()
for(i in 1:length(dvc.list)) {
  dvc.list[[i]] <- NormalizeData(object = dvc.list[[i]], verbose = FALSE)
  dvc.list[[i]] <- FindVariableFeatures(object = dvc.list[[i]], 
                                       selection.method = "vst", nfeatures = 2000, 
                                       verbose = FALSE)
  dvc.list[[i]] <- ScaleData(dvc.list[[i]], vars.to.regress = "nCount_RNA", verbose = FALSE)
  dvc.list[[i]] <- RunPCA(dvc.list[[i]], npcs = 30, verbose = FALSE)
  dvc.list[[i]] <- RunUMAP(dvc.list[[i]], reduction = "pca", dims = 1:30, verbose = FALSE)

  dvc.list[[i]] <- FindNeighbors(object = dvc.list[[i]], dims = 1:30, verbose = FALSE)
  dvc.list[[i]] <- FindClusters(object = dvc.list[[i]], resolution = 0.4, verbose = FALSE)  # Adjust resolution as needed

  # Store cluster assignments
  cluster_assignments_list[[sample_names[i]]] <- dvc.list[[i]]@meta.data$seurat_clusters
  names(cluster_assignments_list[[sample_names[i]]]) <- colnames(dvc.list[[i]])
}  

saveRDS(dvc.list, file = "~/Git/P24-203/data/dvc_list.rds")
```


# Ambient RNA removal
```{r}

# Directory containing your data
counts_directory <- "~/Git/P24-203/data/count"
suffix <- "/outs/"

# Get all sample directories in "data/count"
sample_dirs <- list.dirs(counts_directory, full.names = TRUE, recursive = FALSE)
sample_dirs <- sort(sample_dirs)
sample_names <- gsub(".*/", "", sample_dirs)  # Extract sample names from the folder paths

# Set up parallel backend (adjust cores as needed)
cl <- makeCluster(4)
registerDoParallel(cl)

# Parallel loop to process all samples
scs_list <- foreach(i = 1:length(sample_names), .packages = c("Seurat", "SoupX", "ggplot2")) %dopar% {
  
  sample_name <- sample_names[i]  # Corrected variable name
  
  # Construct paths to raw and filtered feature matrices
  filtered_path <- paste0(sample_dirs[i], suffix, "filtered_feature_bc_matrix")
  raw_path <- paste0(sample_dirs[i], suffix, "raw_feature_bc_matrix")
  
  # Load raw and filtered counts using Seurat's Read10X
  toc <- Seurat::Read10X(filtered_path)
  tod <- Seurat::Read10X(raw_path)
  
  # Ensure matrices are sparse
  tod <- as(tod, "dgCMatrix")  
  toc <- as(toc, "dgCMatrix")  

  # Create a SoupChannel object
  sc <- SoupChannel(tod, toc)
  sc$tod <- tod
  
  # Estimate the soup profile (ambient RNA)
  sc <- estimateSoup(sc)
  
  # Subset joined_seurat to only include cells in sc$toc
  sc_cells <- colnames(sc$toc) 
  sc_cells_renamed <- paste0(sample_name, "_", sc_cells)
  
  dvc.subset <- subset(dvc.list[[sample_name]], cells = sc_cells_renamed)

  #cluster_assignments_subset <- cluster_assignments[colnames(joined_seurat_subset)]
  
  # Extract cluster assignments
  cluster_assignments_subset <- cluster_assignments_list[[sample_name]][colnames(dvc.subset)]
  names(cluster_assignments_subset) <- gsub("^.*_", "", names(cluster_assignments_subset))

  # Handle missing cells
  missing_cells <- setdiff(colnames(sc$toc), names(cluster_assignments_subset))
  cluster_assignments_subset[missing_cells] <- 0

  # Add cluster assignments to SoupX object
  sc <- setClusters(sc, cluster_assignments_subset)

  # Set dimensionality reduction for SoupChannel
  dvc.subset@meta.data$RD1 <- dvc.subset@reductions$umap@cell.embeddings[,1]
  dvc.subset@meta.data$RD2 <- dvc.subset@reductions$umap@cell.embeddings[,2]
  
  sc <- setDR(sc, dvc.subset@meta.data[sc_cells_renamed, c("RD1", "RD2")])

  # Automatically estimate contamination
  sc <- autoEstCont(sc)

  # Adjust counts
  adjusted_counts <- adjustCounts(sc)

  # ----- PLOTTING -----
  dd <- na.omit(dvc.subset@meta.data[sc_cells_renamed, ])
  
  # Plot Seurat Cluster Annotations
  mids = aggregate(cbind(RD1, RD2) ~ seurat_clusters, data = dd, FUN = mean)
  gg = ggplot(dd, aes(RD1, RD2)) +
      geom_point(aes(colour = seurat_clusters), size = 0.2) +
      geom_label(data = mids, aes(label = seurat_clusters)) +
      ggtitle(paste0(sample_name, " - Seurat Cluster Annotation")) +
      guides(colour = guide_legend(override.aes = list(size = 1)))
  ggsave(paste0(sample_name, "_Seurat_Cluster_Annotation.png"), gg)

  # Plot Gfral expression
  dd$gfral <- sc$toc["Gfral", gsub("^.*_", "", rownames(dd))]
  gg1 <- ggplot(dd, aes(RD1, RD2)) + geom_point(aes(colour = gfral > 0))
  ggsave(paste0(sample_name, "_Gfral_Expression.png"), gg1)

  gg1_2 <- plotMarkerMap(sc, "Gfral")
  ggsave(paste0(sample_name, "_Gfral_MarkerMap.png"), gg1_2)

  # Plot Adcysrat1 expression
  dd$adcyap1 <- sc$toc["Adcyap1", gsub("^.*_", "", rownames(dd))]
  gg2 <- ggplot(dd, aes(RD1, RD2)) + geom_point(aes(colour = adcyap1 > 0))
  ggsave(paste0(sample_name, "_Adcyap1_Expression.png"), gg2)

  gg2_2 <- plotMarkerMap(sc, "Adcyap1")
  ggsave(paste0(sample_name, "_Adcyap1_MarkerMap.png"), gg2_2)

  # Plot Change Maps
  gg1_3 <- plotChangeMap(sc, adjusted_counts, "Gfral")
  gg2_3 <- plotChangeMap(sc, adjusted_counts, "Adcyap1")
  ggsave(paste0(sample_name, "_Gfral_ChangeMap.png"), gg1_3)
  ggsave(paste0(sample_name, "_Adcyap1_ChangeMap.png"), gg2_3)

  # Return the processed SoupChannel
  list(sample_name = sample_name, sc = sc)
}

# Stop the cluster after processing
stopCluster(cl)

# Convert results into a named list
scs <- setNames(lapply(scs_list, function(x) x$sc), sapply(scs_list, function(x) x$sample_name))
#saveRDS(scs, "soup_channels_tmp.rds")

```

# Create Seurat objects for each Soup channel
```{r warning=FALSE, message=FALSE}

# Create an empty list to store Seurat objects
srat_list <- list()

# Iterate through each SoupX channel
for (nom in names(scs)) {
    # Clean channel named 'nom'
    tmp <- adjustCounts(scs[[nom]])
    
    # Add experiment name to cell barcodes to make them unique (optional)
    colnames(tmp) <- paste0(nom, "_", colnames(tmp))

    # Create a Seurat object for the current sample
    srat_list[[nom]] <- CreateSeuratObject(counts = tmp, project = nom)
}
```

# Normalization after ambient RNA removal
```{r message=FALSE, warning=FALSE}
srat_list <- lapply(srat_list, function(seurat_obj) {
    seurat_obj <- NormalizeData(seurat_obj)
    seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
    seurat_obj <- ScaleData(seurat_obj, vars.to.regress = "nCount_RNA", verbose = FALSE)
    seurat_obj <- RunPCA(seurat_obj, npcs = 30, verbose = FALSE)
    seurat_obj <- RunUMAP(seurat_obj, reduction = "pca", dims = 1:30, verbose = FALSE)
    seurat_obj <- FindNeighbors(seurat_obj, dims = 1:30, verbose = FALSE)
    seurat_obj <- FindClusters(seurat_obj, resolution = 0.4, verbose = FALSE)
    return(seurat_obj)
})
saveRDS(srat_list, "after_soupx_tmp.rds")
```


# Doublet removal
```{r}
cl <- makeCluster(8)
registerDoParallel(cl)

clusterEvalQ(cl, {
  library(Seurat)
  library(DoubletFinder)
})

srat.list.wodoublets <- foreach(i = 1:length(srat_list), .packages = c("Seurat", "DoubletFinder")) %do% {
  tryCatch({
    set.seed(i)
    
    print(paste("Processing sample:", i))  

    # Check if srat_list[[i]] is valid
    if (is.null(srat_list[[i]])) {
      message(paste("Skipping sample", i, "because it is NULL"))
      return(NULL)
    }

    # Debugging: Check if data exists
    print(dim(srat_list[[i]]@assays$RNA))  

    # pK identification
    sweep.res.list_srat <- paramSweep(srat_list[[i]], PCs = 1:10, sct = FALSE)
    sweep.stats_srat <- summarizeSweep(sweep.res.list_srat, GT = FALSE)
    bcmvn_srat <- find.pK(sweep.stats_srat)
    pK <- bcmvn_srat$pK[which.max(bcmvn_srat$BCmetric)]
    pK <- as.numeric(as.character(pK))

    print(paste("Selected pK:", pK))  

    # Doublet removal 
    nExp_poi <- round(0.035 * ncol(srat_list[[i]]@assays$RNA))
    srat_list[[i]] <- doubletFinder(srat_list[[i]], PCs = 1:10, pN = 0.2, pK = pK, 
                                     nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)

    colnames(srat_list[[i]]@meta.data)[6:7] <- c("pANN", "classifications")

    print(table(srat_list[[i]]@meta.data$classifications))

    srat.wodoublets <- subset(srat_list[[i]], subset = classifications == "Singlet")

    return(srat.wodoublets)  
  }, error = function(e) {
    message(paste("Error in sample", i, ":", e$message))
    return(NULL)
  })
}

# Assign names
names(srat.list.wodoublets) <- names(srat_list)[!sapply(srat.list.wodoublets, is.null)]

#saveRDS(srat.list.wodoublets, file = "~/Git/P24-203/data/srat_list_wo_doublets.rds")

stopCluster(cl)


```

# Combine clean seurat objects
```{r message=FALSE, warning=FALSE}
#srat.list.wodoublets <- readRDS("~/Git/P24-203/data/srat_list_wo_doublets.rds")

joined_seurat <- merge(srat.list.wodoublets[[1]], y = srat.list.wodoublets[-1], merge.data = TRUE)
```

# Normalize joined data set
```{r warning=FALSE}
joined_seurat <- NormalizeData(object = joined_seurat, verbose = FALSE)
joined_seurat <- FindVariableFeatures(object = joined_seurat, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
joined_seurat <- ScaleData(joined_seurat, vars.to.regress = "nCount_RNA", verbose = FALSE)
joined_seurat <- RunPCA(joined_seurat, npcs = 30, verbose = FALSE)
joined_seurat <- RunUMAP(joined_seurat, reduction = "pca", dims = 1:30, verbose = F)

joined_seurat <- FindNeighbors(object = joined_seurat, dims = 1:30, verbose = FALSE)
joined_seurat <- FindClusters(object = joined_seurat, resolution = 0.8, verbose = FALSE)  # Adjust resolution as needed
DimPlot(joined_seurat, reduction = "umap", group.by = "seurat_clusters")

cluster_assignments <- joined_seurat@meta.data$seurat_clusters

names(cluster_assignments) <- colnames(joined_seurat)

saveRDS(joined_seurat, "~/Git/P24-203/data/joined_seurat.rds")

```

# Plot before integration
```{r message=FALSE, warning=FALSE}
# Add a new column to indicate the study
joined_seurat$study <- ifelse(grepl("SRR", colnames(joined_seurat)), "GSE206144", "GSE166649")

before_int <- DimPlot(joined_seurat,reduction = "umap", group.by = "study") + plot_annotation(title = "Both data sets, before integration")
print(before_int)
ggsave(here("img/before_integration.png"),before_int)
```

# Integration
```{r message=FALSE, warning=FALSE}
joined_seurat <- joined_seurat %>% RunHarmony("orig.ident", plot_convergence = T)
```

# Check embeddings
```{r}
harmony_embeddings <- Embeddings(joined_seurat, 'harmony')
harmony_embeddings[1:5, 1:5]
```

# Check PCA plot after integration
```{r}

p1 <- DimPlot(object = joined_seurat, reduction = "harmony", pt.size = .1, group.by = "orig.ident") + NoLegend()
p2 <- VlnPlot(object = joined_seurat, features = "harmony_1", group.by = "orig.ident", pt.size = .1) + NoLegend()
plot_grid(p1,p2)

```

# UMAP and clustering
```{r message=FALSE, warning=FALSE}
joined_seurat <- joined_seurat %>% 
  RunUMAP(reduction = "harmony", dims = 1:30, verbose = FALSE) %>% 
  FindNeighbors(reduction = "harmony", k.param = 10, dims = 1:30) %>% 
  FindClusters() %>% 
  identity()
```

# Plot per sample after integration 

```{r}
DimPlot(joined_seurat, reduction = "umap", group.by = "orig.ident", pt.size = .1, split.by = 'orig.ident') + NoLegend()
```

# Plot data sets after integration
```{r}
after_int <- DimPlot(joined_seurat,reduction = "umap", group.by = "study") + plot_annotation(title = "Both data sets, after integration")
print(after_int)
ggsave(here("img/after_integration.png"),after_int)
```

# Plot the Seurat clusters
```{r}
joined_seurat <- SetIdent(joined_seurat, value = "seurat_clusters")
d <- DimPlot(joined_seurat,label = TRUE) + NoLegend()
print(d)
ggsave(here("img/seurat_clusters_all_cells.png"), d)

```

# Cluster content
```{r message=FALSE, warning=FALSE}
p <- plot_integrated_clusters(joined_seurat)
print(p)
ggsave(here("img/clus_comp_all.png"),p)
```


# Annotation NTS vs AP

```{r message=FALSE, warning=FALSE}

ap_markers <- read.csv("~/Git/P24-203/doc/marker_genes_AP.csv", header = TRUE, stringsAsFactors = FALSE)
nts_markers <- read.csv("~/Git/P24-203/doc/marker_genes_NTS.csv", header = TRUE, stringsAsFactors = FALSE)

# Ensure the marker genes are present in your dataset
ap_markers <- intersect(unlist(ap_markers$gene), rownames(joined_seurat@assays$RNA))
nts_markers <- intersect(unlist(nts_markers$gene), rownames(joined_seurat@assays$RNA))

cluster_avg_expression <- AggregateExpression(joined_seurat, features = c(ap_markers, nts_markers), group.by = "seurat_clusters")$RNA

ap_expression <- cluster_avg_expression[ap_markers, ]
nts_expression <- cluster_avg_expression[nts_markers, ]

ap_cluster_scores <- colMeans(ap_expression, na.rm = TRUE)
nts_cluster_scores <- colMeans(nts_expression, na.rm = TRUE)

cluster_annotations <- ifelse(ap_cluster_scores > nts_cluster_scores, "AP", "NTS")
names(cluster_annotations) <- 0:33
mapped_annotations <- cluster_annotations[as.character(joined_seurat$seurat_clusters)]
names(mapped_annotations) <- rownames(joined_seurat@meta.data)  # Set names to cell IDs
joined_seurat$AP_NTS_Cluster_Annotation <- mapped_annotations[rownames(joined_seurat@meta.data)]

# Visualization with annotations
ap_nts <- DimPlot(joined_seurat, reduction = "umap", group.by = "AP_NTS_Cluster_Annotation", label = TRUE) +
  theme(legend.position = "none") +
  xlab("umap1") + ylab("umap2")

ggsave(here("img/ap_nts_all_cells.png"), ap_nts)
print(ap_nts)
saveRDS(joined_seurat, "~/Git/P24-203/data/joined_seurat_integrated.rds")
```

# GOI expression in all cells
```{r}
ft1 <- FeaturePlot(joined_seurat, features = c("Gfral", "Adcyap1"), min.cutoff = "q10")
ft2 <- FeaturePlot(joined_seurat, features = c("Gfral", "Adcyap1"), blend = TRUE, pt.size = 0.1) +
  theme(plot.title = element_text(hjust = 0.5))
gfral_cells <- WhichCells(joined_seurat, expression = Gfral > 0)
adcyap1_cells <- WhichCells(joined_seurat, expression = Adcyap1 > 0)

print(ft1)
print(ft2)

# Find cells that express both genes
overlap_cells <- intersect(gfral_cells, adcyap1_cells)

# Compute percentages
total_cells <- length(Cells(joined_seurat))
gfral_pct <- length(gfral_cells) / total_cells * 100
adcyap1_pct <- length(adcyap1_cells) / total_cells * 100
overlap_pct <- length(overlap_cells) / total_cells * 100

# Print results
cat("Percentage of cells expressing Gfral:", round(gfral_pct, 2), "%\n")
cat("Percentage of cells expressing Adcyap1:", round(adcyap1_pct, 2), "%\n")
cat("Percentage of cells expressing both genes:", round(overlap_pct, 2), "%\n")

```

# Create SCE
```{r}

# Extract all layers containing raw counts
count_layers <- grep("^counts\\.", names(joined_seurat@assays$RNA@layers), value = TRUE)

# Merge all count matrices
counts_combined <- do.call(cbind, lapply(count_layers, function(layer) {
  joined_seurat@assays$RNA@layers[[layer]]
}))

# Create SingleCellExperiment object
sce <- SingleCellExperiment(
  assays = list(counts = counts_combined),
  colData = joined_seurat@meta.data  # Transfer metadata from Seurat
)

# Normalize counts
sce <- logNormCounts(sce)
assayNames(sce)

# Save for later use
saveRDS(sce, here("data/joined_sce.rds"))

```
# Non-neuron markers
```{r}
non_neurons <- list.files(here("data/csv/non_neurons"), pattern = "*.csv", full.names = TRUE)

non_neuron_data <- lapply(non_neurons, read.csv)
names(non_neuron_data) <- gsub("*.csv", "", basename(non_neurons))
cellex_cutoff <- 0.9
expr_proportion_cutoff <- 10

# Loop through the list and filter each data frame
non_neuron_filtered_data <- lapply(non_neuron_data, function(df) {
  subset(df, cellex_score >= cellex_cutoff & expr_proportion >= expr_proportion_cutoff)
})

output_dir <- here("data/marker_genes")  # Directory to save the files

lapply(seq_along(non_neuron_filtered_data), function(i) {
  output_file <- file.path(output_dir, paste0("marker_genes_", names(non_neuron_filtered_data)[i]))
  write_csv(as.data.frame(non_neuron_filtered_data[[i]]$gene), output_file, col_names = FALSE)
})
```

# Neuron markers 
```{r}
neurons <- list.files(here("data/csv/neurons"), pattern = "*.csv", full.names = TRUE)

neuron_data <- lapply(neurons, read.csv)
names(neuron_data) <- gsub("*.csv", "", basename(neurons))
cellex_cutoff <- 0.9
expr_proportion_cutoff <- 10

# Loop through the list and filter each data frame
neuron_filtered_data <- lapply(neuron_data, function(df) {
  subset(df, cellex_score >= cellex_cutoff & expr_proportion >= expr_proportion_cutoff)
})

output_dir <- here("data/marker_genes")  # Directory to save the files

lapply(seq_along(neuron_filtered_data), function(i) {
  output_file <- file.path(output_dir, paste0("marker_genes_", names(neuron_filtered_data)[i]))
  write_csv(as.data.frame(neuron_filtered_data[[i]]$gene), output_file, col_names = FALSE)
})
```

# Cluster annotation (non-neurons + neurons)
```{r message=FALSE, warning=FALSE}

# Define directory where your marker gene files are stored
marker_dir <- here("data/marker_genes") 

# List all marker gene files
marker_files <- list.files(marker_dir, pattern = "marker_genes_.*\\.csv", full.names = TRUE)

# Extract cell type names from the file names
cell_types <- gsub("marker_genes_|\\.csv", "", basename(marker_files))

# Read marker gene lists and assign cell type names
marker_gene_lists <- lapply(marker_files, function(file) {
  data <- read.csv(file, header = TRUE, stringsAsFactors = FALSE)
  unlist(data)  # Ensure the marker genes are a character vector
})
names(marker_gene_lists) <- cell_types  # Add cell type names to the list

# Ensure the marker genes are present in your dataset
filtered_marker_genes <- lapply(marker_gene_lists, function(genes) {
  intersect(genes, rownames(joined_seurat@assays$RNA))
})

all.sets <- lapply(names(filtered_marker_genes), function(x) {
    GeneSet(filtered_marker_genes[[x]], setName=x)        
})
all.sets <- GeneSetCollection(all.sets)

rownames(sce) <- rownames(joined_seurat)

rankings <- AUCell_buildRankings(counts(sce),
    plotStats=FALSE, verbose=FALSE)
gc()
cell.aucs <- AUCell_calcAUC(all.sets, rankings)

results <- t(assay(cell.aucs))
head(results)

saveRDS(results, here("data/cell_anno_results.rds"))

new.labels <- colnames(results)[max.col(results)]
tab <- table(new.labels, sce$seurat_clusters)

# Plot to see the distribution of AUCs across cells for each label

#plot_grid(AUCell_exploreThresholds(cell.aucs[2], plotHist=TRUE, assign=TRUE), 
#          AUCell_exploreThresholds(cell.aucs[10], plotHist=TRUE, assign=TRUE), 
#          AUCell_exploreThresholds(cell.aucs[15], plotHist=TRUE, assign=TRUE),
#          AUCell_exploreThresholds(cell.aucs[22], plotHist=TRUE, assign=TRUE))


```
# Plot cluster annotation
```{r message=FALSE, warning=FALSE}
joined_seurat$predicted_cell_type <- new.labels

# Plot with predicted cell types
options(ggrepel.max.overlaps = Inf)
all_cells <- DimPlot(joined_seurat, group.by = "predicted_cell_type", label = TRUE, repel = TRUE) + 
  ggtitle("Predicted Cell Type Annotations")
print(all_cells)
ggsave(here("img/all_cells_plot.png"), all_cells)

```

# Gene expression overlap by cluster

```{r message=FALSE, warning=FALSE} 
# Get cell type identities
Idents(joined_seurat) <- "predicted_cell_type"  # Replace with the correct metadata column for clusters

# Function to compute percentages per cell type
get_overlap_by_cluster <- function(seurat_obj, gene1, gene2) {
  cluster_levels <- levels(seurat_obj)
  results <- data.frame(Cluster = character(), Gfral_pct = numeric(), Adcyap1_pct = numeric(), Both_pct = numeric())
  
  for (cluster in cluster_levels) {
    cells_in_cluster <- WhichCells(seurat_obj, idents = cluster)
    
    gfral_cells <- WhichCells(seurat_obj, expression = !!sym(gene1) > 0)
    adcyap1_cells <- WhichCells(seurat_obj, expression = !!sym(gene2) > 0)
    
    overlap_cells <- intersect(gfral_cells, adcyap1_cells)
    
    gfral_pct <- round(length(intersect(cells_in_cluster, gfral_cells)) / length(cells_in_cluster) * 100,3)
    adcyap1_pct <- round(length(intersect(cells_in_cluster, adcyap1_cells)) / length(cells_in_cluster) * 100,3)
    overlap_pct <- round(length(intersect(cells_in_cluster, overlap_cells)) / length(cells_in_cluster) * 100,3)
    
    results <- rbind(results, data.frame(Cluster = cluster, Gfral_pct = gfral_pct, Adcyap1_pct = adcyap1_pct, Both_pct = overlap_pct))
  }
  
  return(results)
}

# Run the function
overlap_results <- get_overlap_by_cluster(joined_seurat, "Gfral", "Adcyap1")
print(overlap_results)

```

# Subset to keep annotated neurons
```{r message=FALSE, warning=FALSE}
neuron_types = c("chat1","chat2","chat3","Glu1","Glu2","Glu3","Glu4","Glu5","Glu6",
                 "Glu7","Glu8","Glu9","Glu10","Glu11","Glu12","Glu13","Glu14","Glu15",
                 "GABA1","GABA2","GABA3","GABA4","GABA5","GABA6","GABA7")

non_neuron_types = c("astrocytes","OPCs","ependymal_cells","endothelial_cells",
                     "oligodendrocytes","tancyte-like_cells","microglia","VLMCs")

joined_seurat$neuron_status <- ifelse(joined_seurat$predicted_cell_type %in% neuron_types, "neuron", "non-neuron")


neuron_seurat <- subset(joined_seurat, subset = neuron_status == "neuron")


overlap_results_neuron <- get_overlap_by_cluster(neuron_seurat, "Gfral", "Adcyap1")
print(overlap_results_neuron)

DimPlot(neuron_seurat, group.by = "predicted_cell_type", label = TRUE, repel = TRUE) + 
  ggtitle("Predicted Cell Type Annotations")

```

# Re-scale and re-cluster neurons
```{r message=FALSE, warning=FALSE}

neuron_seurat <- FindVariableFeatures(object = neuron_seurat, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
neuron_seurat <- ScaleData(neuron_seurat, vars.to.regress = "nCount_RNA", verbose = FALSE)
neuron_seurat <- RunPCA(neuron_seurat, npcs = 30, verbose = FALSE)
ElbowPlot(neuron_seurat)
neuron_seurat <- RunUMAP(neuron_seurat, reduction = "pca", dims = 1:10, verbose = F)

neuron_seurat <- FindNeighbors(object = neuron_seurat, dims = 1:30, verbose = FALSE)
neuron_seurat <- FindClusters(object = neuron_seurat, resolution = 0.8, verbose = FALSE) 

neuron_seurat <- SetIdent(neuron_seurat, value = "RNA_snn_res.0.8")
clus <- DimPlot(neuron_seurat,label = TRUE) + NoLegend()
print(clus)
ggsave(here("img/neuron_clusters_res_0.8.png"), clus)

cluster_assignments <- neuron_seurat@meta.data$seurat_clusters

names(cluster_assignments) <- colnames(neuron_seurat)

saveRDS(neuron_seurat, here("data/neuron_subset.rds"))

```

# Neuron cluster composition
```{r message=FALSE, warning=FALSE}
neuron_clus_comp <- plot_integrated_clusters(neuron_seurat)
print(neuron_clus_comp)
ggsave(here("img/neuron_cluster_comp.png"), neuron_clus_comp)
```

# Plot the expression values for Gfral/Adcyap1 in neurons
```{r message=FALSE, warning=FALSE}
ft1 <- FeaturePlot(neuron_seurat, features = c("Gfral", "Adcyap1"), min.cutoff = "q10")
ft2 <- FeaturePlot(neuron_seurat, features = c("Gfral", "Adcyap1"), blend = TRUE, pt.size = 0.1) +
  theme(plot.title = element_text(hjust = 0.5))
gfral_cells <- WhichCells(neuron_seurat, expression = Gfral > 0)
adcyap1_cells <- WhichCells(neuron_seurat, expression = Adcyap1 > 0)

print(ft1)
print(ft2)
ggsave(here("img/expression_gfral_adcyap1_neurons.png"), ft1)
ggsave(here("img/Co-expression_gfral_adcyap1_neurons.png"), ft2)
```

# Check AP/NTS annotation in neurons
```{r}
DimPlot(neuron_seurat, group.by = "AP_NTS_Cluster_Annotation", label = TRUE, repel = TRUE) + 
  ggtitle("Neuron AP or NTS")
```

# Re-annotate neuron clusters
```{r message=FALSE, warning=FALSE}
# Create SingleCellExperiment object
count_layers <- grep("^counts\\.", names(neuron_seurat@assays$RNA@layers), value = TRUE)

# Merge all count matrices
counts_combined <- do.call(cbind, lapply(count_layers, function(layer) {
  neuron_seurat@assays$RNA@layers[[layer]]
}))

sce_neuron <- SingleCellExperiment(
  assays = list(counts = counts_combined),
  colData = neuron_seurat@meta.data  # Transfer metadata from Seurat
)

# Normalize counts
sce_neuron <- logNormCounts(sce_neuron)
assayNames(sce_neuron)

rownames(sce_neuron) <- rownames(neuron_seurat)

saveRDS(sce_neuron, here("data/sce_neuron.rds"))
#sce_neuron <- readRDS(here("data/sce_neuron.rds"))
#neuron_seurat <- readRDS(here("data/neuron_subset.rds"))

## MARKER GENE SET ## 
# Load marker genes
marker_dir <- here("data/neuron_marker_genes")  # Update with your actual path

# List all marker gene files
marker_files <- list.files(marker_dir, pattern = "marker_genes_.*\\.csv", full.names = TRUE)

# Extract cell type names from the file names
cell_types <- gsub("marker_genes_|\\.csv", "", basename(marker_files))

# Read marker gene lists and assign cell type names
marker_gene_lists <- lapply(marker_files, function(file) {
  data <- read.csv(file, header = TRUE, stringsAsFactors = FALSE)
  unlist(data)  # Ensure the marker genes are a character vector
})
names(marker_gene_lists) <- cell_types  # Add cell type names to the list

# Ensure the marker genes are present in your dataset
filtered_marker_genes <- lapply(marker_gene_lists, function(genes) {
  intersect(genes, rownames(neuron_seurat@assays$RNA))
})

all.sets <- lapply(names(filtered_marker_genes), function(x) {
    GeneSet(filtered_marker_genes[[x]], setName=x)        
})
all.sets <- GeneSetCollection(all.sets)

## ANNOTATION ## 
rankings <- AUCell_buildRankings(counts(sce_neuron),
    plotStats=FALSE, verbose=FALSE)
cell.aucs <- AUCell_calcAUC(all.sets, rankings)

results <- t(assay(cell.aucs))
head(results)
neuron_results <- results
saveRDS(results, here("data/neuron_cell_anno_results.rds"))

#results <- readRDS(here("data/neuron_cell_anno_results.rds"))
new.labels <- colnames(results)[max.col(results)]

neuron_seurat$neuron_cell_type <- new.labels
table(neuron_seurat$neuron_cell_type, neuron_seurat$RNA_snn_res.0.8)
# Plot with predicted cell types
options(ggrepel.max.overlaps = Inf)
neuron_seurat <- SetIdent(neuron_seurat, value = "RNA_snn_res.0.8")
neuron_ann <- DimPlot(neuron_seurat, group.by = "neuron_cell_type", label = TRUE, repel = TRUE) + 
  ggtitle("Predicted Neuron Cell Type Annotations")
print(neuron_ann)
ggsave(here("img/neuron_anno_clusters.png"), neuron_ann)
```

```{r}
# Get cell type identities
Idents(neuron_seurat) <- "neuron_cell_type"
overlap_results <- get_overlap_by_cluster(neuron_seurat, "Gfral", "Adcyap1")
print(overlap_results)
```
# Look at the Pearson and Spearman coeffcients for co-expression Gfral/Adcyap1
```{r message=FALSE, warning=FALSE}
# Extract expression values for two genes
gene1 <- "Gfral"  # Replace with your gene name
gene2 <- "Adcyap1"

all_data_layers <- grep("^data\\.", Layers(neuron_seurat[["RNA"]]), value = TRUE)
# Extract expression data from all layers and combine
expr_list <- lapply(all_data_layers, function(layer) {
  GetAssayData(neuron_seurat, assay = "RNA", layer = layer)
})

# Merge all extracted expression matrices (column-wise: cells are in columns)
expr_matrix_all <- do.call(cbind, expr_list)
expr_gene1 <- expr_matrix_all[gene1, ]
expr_gene2 <- expr_matrix_all[gene2, ]

Idents(neuron_seurat) <- "neuron_cell_type"

# Compute Pearson correlation
correlation <- cor(expr_gene1, expr_gene2, method = "pearson", use = "complete.obs")
print(correlation)

get_gene_correlation_by_cluster <- function(seurat_obj, gene1, gene2) {
  cluster_levels <- levels(seurat_obj)
  results <- data.frame(Cluster = character(), Pearson = numeric(), Spearman = numeric())
  
  for (cluster in cluster_levels) {
    cells_in_cluster <- WhichCells(seurat_obj, idents = cluster)
    
    expr_gene1 <- FetchData(seurat_obj, vars = gene1)[cells_in_cluster, , drop = FALSE]
    expr_gene2 <- FetchData(seurat_obj, vars = gene2)[cells_in_cluster, , drop = FALSE]
    
    if (length(cells_in_cluster) > 5) {  # Avoid errors with very small clusters
      pearson_corr <- cor(expr_gene1[, 1], expr_gene2[, 1], method = "pearson", use = "complete.obs")
      spearman_corr <- cor(expr_gene1[, 1], expr_gene2[, 1], method = "spearman", use = "complete.obs")
      
      results <- rbind(results, data.frame(Cluster = cluster, Pearson = pearson_corr, Spearman = spearman_corr))
    }
  }
  
  return(results)
}

# Run the function
correlation_results <- get_gene_correlation_by_cluster(neuron_seurat, "Gfral", "Adcyap1")
print(correlation_results)


```

# Run scLink to look at the co-expression Gfral/Adcyap1
```{r message=FALSE, warning=FALSE}
#saveRDS(expr_matrix_all, here("data/expr_matrix_all.rds"))
#saveRDS(neuron_seurat, here("data/neuron_seurat_2.rds"))
count <- t(expr_matrix_all)
genes <- c("Gfral","Adcyap1","Glp1r","Gpc3")

count.norm <- sclink_norm(count, scale.factor = 1e6, filter.genes = FALSE, gene.names = genes)
gc()

networks <- sclink_net(expr = count.norm, ncores = 1, lda = seq(0.5, 0.1, -0.05))

networks$cor[1:4,1:4]

```

# Results for one cluster from scLink
```{r}
net1 = networks$summary[[1]]

names(net1)
```

# Run scLink for only one cell type
```{r message=FALSE, warning=FALSE}
# Ensure the active identity class is set to the clustering result
Idents(neuron_seurat) <- "predicted_cell_type"  # Replace with your clustering column name

# Subset the Seurat object to include only "Glu4" cells
glu4_seurat <- subset(neuron_seurat, idents = "Glu5")

glu4_data_layers <- grep("^data\\.", Layers(glu4_seurat[["RNA"]]), value = TRUE)
# Extract expression data from all layers and combine
expr_list <- lapply(glu4_data_layers, function(layer) {
  mat <- GetAssayData(glu4_seurat, assay = "RNA", layer = layer)
  
  # Check if the matrix is not NULL and has dimensions
  if (!is.null(mat) && length(dim(mat)) == 2) {
    return(mat)
  } else {
    return(NULL)  # Skip this layer if it's NULL or has no dimensions
  }
})

# Remove NULL entries from the list
expr_list <- Filter(Negate(is.null), expr_list)

# Merge all extracted expression matrices (column-wise: cells are in columns)
expr_matrix_glu4 <- do.call(cbind, expr_list)

count <- t(expr_matrix_glu4)
genes <- c("Gfral","Adcyap1","Glp1r","Gpc3")

count.norm <- sclink_norm(count, scale.factor = 1e6, filter.genes = FALSE, gene.names = genes)
gc()

networks <- sclink_net(expr = count.norm, ncores = 1, lda = seq(0.5, 0.1, -0.05))
networks$cor[1:4,1:4]
```

# Run scLink per cell type
```{r message=FALSE, warning=FALSE}

process_neuron_cell_type <- function(neuron_seurat, cell_type, genes) {
  # Ensure the active identity class is set to the clustering result
  Idents(neuron_seurat) <- "neuron_cell_type"  # Replace with your clustering column name
  
  # Subset the Seurat object to include the specified neuron cell type
  neuron_seurat_subset <- subset(neuron_seurat, idents = cell_type)
  
  # Extract data layers
  data_layers <- grep("^data\\.", Layers(neuron_seurat_subset[["RNA"]]), value = TRUE)
  
  # Extract expression data from all layers and combine
  expr_list <- lapply(data_layers, function(layer) {
    layer_data <- neuron_seurat_subset[["RNA"]]@layers[[layer]]
    
    # Check if layer data is of type S4 and not NULL
    if (!is.null(layer_data)) {
      if (inherits(layer_data, "matrix") || inherits(layer_data, "dgCMatrix")) {
        mat <- GetAssayData(neuron_seurat_subset, assay = "RNA", layer = layer)
        
        cat("Processing layer:", layer, "with dimensions:", dim(mat), "\n")
        
        # Check if the matrix has two dimensions (genes x cells)
        if (length(dim(mat)) == 2) {
          return(mat)
        } else {
          warning(paste("Layer", layer, "does not have the expected two dimensions."))
          return(NULL)  # Skip this layer if it doesn't meet the criteria
        }
      } else {
        warning(paste("Layer", layer, "is not of type S4 or is unexpected. Skipping."))
        return(NULL)  # Skip this layer if it's not an S4 object
      }
    } else {
      warning(paste("Layer", layer, "is NULL. Skipping."))
      return(NULL)  # Skip this layer if it's NULL
    }
  })
  
  # Remove NULL entries from the list
  expr_list <- Filter(Negate(is.null), expr_list)
  
  # Check if there are any valid expression matrices
  if (length(expr_list) == 0) {
    stop(paste("No valid expression matrices found for cell type:", cell_type))
  }
  
  # Merge all extracted expression matrices (column-wise: cells are in columns)
  expr_matrix <- do.call(cbind, expr_list)
  
  count <- t(expr_matrix)
  
  # Normalize counts
  count.norm <- sclink_norm(count, scale.factor = 1e6, filter.genes = FALSE, gene.names = genes)
  
  gc()
  
  # Create networks
  networks <- tryCatch({
    sclink_net(expr = count.norm, ncores = 1, lda = seq(0.5, 0.1, -0.05))
  }, error = function(e) {
    warning(paste("Error in creating networks for cell type:", cell_type, "\n", e$message))
    return(NULL)
  })
  
  if (!is.null(networks)) {
    return(networks$cor[1:4, 1:4])
  } else {
    return(NULL)  # Return NULL if network creation failed
  }
}

# Loop over all neuron cell types
results <- lapply(neuron_cell_types, function(cell_type) {
  cat("Processing cell type:", cell_type, "\n")
  process_neuron_cell_type(neuron_seurat, cell_type, genes)
})

# Optionally, name the results for easy identification
names(results) <- neuron_cell_types


# Initialize a data frame to hold co-expression values
co_expression_values <- data.frame(CellType = character(), CoExpression = numeric(), stringsAsFactors = FALSE)

# Loop through each entry in results
for (cell_type in names(results)) {
  # Extract the correlation matrix for the current cell type
  cor_matrix <- results[[cell_type]]
  
  # Check if the matrix contains both genes
  if ("Gfral" %in% rownames(cor_matrix) && "Adcyap1" %in% colnames(cor_matrix)) {
    # Extract the co-expression value for Gfral and Adcyap1
    co_expression_value <- cor_matrix["Gfral", "Adcyap1"]
    
    # Append the result to the data frame
    co_expression_values <- rbind(co_expression_values, data.frame(CellType = cell_type, CoExpression = co_expression_value))
  }
}

```
# Plot co-expression values for Gfral/Adcyap1 per cell type 
```{r message=FALSE, warning=FALSE}
# Extract Adcyap1 correlation values from the Gfral row
gfral_adcyap1_values <- sapply(results, function(x) {
  val <- x["Gfral", "Adcyap1"]
  if (is.null(val)) NA else as.numeric(val)  # Convert NULLs to NA and ensure numeric
})

# Convert to a 1-row numeric matrix
gfral_adcyap1_matrix <- matrix(gfral_adcyap1_values, nrow = 1)
rownames(gfral_adcyap1_matrix) <- "Gfral-Adcyap1"
colnames(gfral_adcyap1_matrix) <- names(results)

# Replace NA values with 0 or use na.color argument in pheatmap
gfral_adcyap1_matrix[is.na(gfral_adcyap1_matrix)] <- 0  

# Create heatmap
p <- pheatmap(
  gfral_adcyap1_matrix,
  cluster_rows = FALSE,  # No need to cluster one row
  cluster_cols = TRUE,   # Cluster cell types
  color = colorRampPalette(c("blue", "white", "red"))(100),
  main = "Gfral-Adcyap1 Co-expression Across Cell Types",
  na_col = "gray"  # Optionally mark NA values in gray instead of replacing with 0
)
print(p)
ggsave(here("img/heatmap_cluster_coexp.png"), p)
```
# Print co-expression values for only Glu4 cluster
```{r message=FALSE, warning=FALSE}
p_glu4 <- pheatmap(results[["Glu4"]])
print(p)
ggsave(here("img/heatmap_glu4_cluster.png"),p_glu4)
```

# Session Info
<details><summary>Session Info</summary>
```{r session info}
sessionInfo()
```
</details>

